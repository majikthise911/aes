import pandas as pd
import json
from typing import Dict, List, Optional
from datetime import datetime

class DataManager:
    """Manages proposal data storage and comparison."""

    def __init__(self):
        self.proposals: List[Dict] = []

    def add_proposal(self, proposal_data: Dict, filename: str) -> bool:
        """Add a new proposal to the collection. Returns True if added, False if duplicate."""
        # Check if this filename already exists
        for existing_proposal in self.proposals:
            if existing_proposal.get('metadata', {}).get('filename') == filename:
                return False  # Already exists, don't add duplicate

        proposal_data['metadata'] = {
            'filename': filename,
            'uploaded_at': datetime.now().isoformat(),
            'id': len(self.proposals)
        }
        self.proposals.append(proposal_data)
        return True  # Successfully added

    def get_all_proposals(self) -> List[Dict]:
        """Return all stored proposals."""
        return self.proposals

    def get_proposal_by_id(self, proposal_id: int) -> Optional[Dict]:
        """Get a specific proposal by ID."""
        for proposal in self.proposals:
            if proposal.get('metadata', {}).get('id') == proposal_id:
                return proposal
        return None

    def create_comparison_dataframe(self, proposals: Optional[List[Dict]] = None) -> pd.DataFrame:
        """Create a DataFrame for EPC contractor comparison."""
        # Use provided proposals list, or fall back to all proposals
        proposals_to_use = proposals if proposals is not None else self.proposals

        if not proposals_to_use:
            return pd.DataFrame()

        comparison_data = []

        for proposal in proposals_to_use:
            epc = proposal.get('epc_contractor', {})
            row_data = {
                'EPC Contractor': epc.get('company_name', 'Unknown EPC'),
                'Project Name': proposal.get('project_info', {}).get('project_name', 'N/A'),
                'Proposal Date': epc.get('proposal_date', 'N/A'),
                'Total Cost ($)': proposal.get('costs', {}).get('total_project_cost', 'N/A'),
                'Cost per Watt DC ($/W)': proposal.get('costs', {}).get('cost_per_watt_dc', 'N/A'),
                'AC Capacity (MW)': proposal.get('capacity', {}).get('ac_mw', 'N/A'),
                'DC Capacity (MW)': proposal.get('capacity', {}).get('dc_mw', 'N/A'),
                'Technology': proposal.get('technology', {}).get('type', 'N/A'),
                'Modules': f"{proposal.get('equipment', {}).get('modules', {}).get('manufacturer', 'N/A')} {proposal.get('equipment', {}).get('modules', {}).get('model', '')}".strip(),
                'Inverters': f"{proposal.get('equipment', {}).get('inverters', {}).get('manufacturer', 'N/A')} {proposal.get('equipment', {}).get('inverters', {}).get('model', '')}".strip(),
                'Contact': epc.get('contact_person', 'N/A'),
                'Email': epc.get('email', 'N/A'),
                'Comments': proposal.get('metadata', {}).get('comments', ''),
                'Filename': proposal.get('metadata', {}).get('filename', 'N/A')
            }
            comparison_data.append(row_data)

        return pd.DataFrame(comparison_data)

    def create_epc_ranking_dataframe(self, proposals: Optional[List[Dict]] = None) -> pd.DataFrame:
        """Create a simplified ranking table for EPC selection."""
        # Use provided proposals list, or fall back to all proposals
        proposals_to_use = proposals if proposals is not None else self.proposals

        if not proposals_to_use:
            return pd.DataFrame()

        ranking_data = []

        for proposal in proposals_to_use:
            epc = proposal.get('epc_contractor', {})
            costs = proposal.get('costs', {})

            # Calculate cost rankings (lower is better)
            total_cost = costs.get('total_project_cost')
            cost_per_watt = costs.get('cost_per_watt_dc')

            row_data = {
                'EPC Contractor': epc.get('company_name', 'Unknown EPC'),
                'Total Cost ($)': total_cost if total_cost else 'N/A',
                'Cost/Watt DC ($/W)': cost_per_watt if cost_per_watt else 'N/A',
                'Equipment Cost ($)': costs.get('cost_breakdown', {}).get('equipment', 'N/A'),
                'Labor Cost ($)': costs.get('cost_breakdown', {}).get('labor', 'N/A'),
                'Module Brand': proposal.get('equipment', {}).get('modules', {}).get('manufacturer', 'N/A'),
                'Inverter Brand': proposal.get('equipment', {}).get('inverters', {}).get('manufacturer', 'N/A'),
                'Proposal Date': epc.get('proposal_date', 'N/A'),
                'Contact': epc.get('contact_person', 'N/A')
            }
            ranking_data.append(row_data)

        df = pd.DataFrame(ranking_data)

        # Sort by total cost (lowest first) if cost data is available
        if 'Total Cost ($)' in df.columns:
            # Convert to numeric for sorting, keeping N/A values at the end
            df['_sort_cost'] = pd.to_numeric(df['Total Cost ($)'], errors='coerce')
            # Sort with NaN values at the end (compatible with older pandas versions)
            df = df.sort_values('_sort_cost', ascending=True, na_position='last')
            df = df.drop('_sort_cost', axis=1)

        return df

    def filter_proposals(self, filters: Dict) -> List[Dict]:
        """Filter proposals based on criteria."""
        filtered_proposals = self.proposals.copy()

        if filters.get('technology'):
            tech_filter = filters['technology'].lower()
            filtered_proposals = [
                p for p in filtered_proposals
                if tech_filter in p.get('technology', {}).get('type', '').lower()
            ]

        if filters.get('min_capacity'):
            min_cap = float(filters['min_capacity'])
            filtered_proposals = [
                p for p in filtered_proposals
                if p.get('capacity', {}).get('ac_mw') and p['capacity']['ac_mw'] >= min_cap
            ]

        if filters.get('max_capacity'):
            max_cap = float(filters['max_capacity'])
            filtered_proposals = [
                p for p in filtered_proposals
                if p.get('capacity', {}).get('ac_mw') and p['capacity']['ac_mw'] <= max_cap
            ]

        if filters.get('state'):
            state_filter = filters['state'].lower()
            filtered_proposals = [
                p for p in filtered_proposals
                if state_filter in p.get('project_info', {}).get('location', {}).get('state', '').lower()
            ]

        return filtered_proposals

    def get_cost_summary(self) -> Dict:
        """Generate cost analysis summary across all proposals."""
        if not self.proposals:
            return {}

        costs = []
        cost_per_watt = []

        for proposal in self.proposals:
            total_cost = proposal.get('costs', {}).get('total_project_cost')
            cpw = proposal.get('costs', {}).get('cost_per_watt_dc')

            if total_cost:
                costs.append(total_cost)
            if cpw:
                cost_per_watt.append(cpw)

        summary = {}
        if costs:
            summary['total_cost'] = {
                'min': min(costs),
                'max': max(costs),
                'avg': sum(costs) / len(costs),
                'count': len(costs)
            }

        if cost_per_watt:
            summary['cost_per_watt'] = {
                'min': min(cost_per_watt),
                'max': max(cost_per_watt),
                'avg': sum(cost_per_watt) / len(cost_per_watt),
                'count': len(cost_per_watt)
            }

        return summary

    def clear_all_proposals(self) -> None:
        """Clear all stored proposals and delete associated PDF files."""
        import os
        from config import PROPOSALS_DIR

        # Delete all stored PDF files
        for proposal in self.proposals:
            pdf_path = proposal.get('metadata', {}).get('pdf_path')
            if pdf_path and os.path.exists(pdf_path):
                try:
                    os.remove(pdf_path)
                except Exception as e:
                    print(f"Warning: Could not delete {pdf_path}: {e}")

        # Clear proposals list
        self.proposals = []