import openai
import os
import json
from typing import Dict, List, Optional, Tuple
import pandas as pd

class CommandAI:
    """AI assistant that interprets natural language commands to control the app."""

    def __init__(self):
        self.client = openai.OpenAI(api_key=os.getenv('OPENAI_API_KEY'))
        self.pending_file = None
        self.pending_action = None

    def interpret_command(self, user_message: str, proposals: List[Dict], has_file: bool = False) -> Dict:
        """
        Interpret user command and determine action to take.

        Returns:
            {
                'action': 'update_proposal' | 'delete_proposal' | 'filter' | 'question' | 'upload_file' | 'clarify',
                'target': 'epc_name or proposal identifier',
                'parameters': {...},
                'response': 'message to user',
                'needs_file': bool,
                'needs_confirmation': bool
            }
        """

        # Get list of EPC names for context
        epc_names = [p.get('epc_contractor', {}).get('company_name', 'Unknown') for p in proposals]

        prompt = f"""You are an AI assistant that interprets user commands for an EPC proposal management system.

Current proposals in system: {', '.join(epc_names) if epc_names else 'None'}

User said: "{user_message}"
File uploaded with message: {has_file}

Determine the user's intent and return a JSON object with:
{{
    "action": "edit_proposal" | "delete_proposal" | "add_cost_data" | "filter" | "question" | "upload_file" | "clarify",
    "target_epc": "name of EPC contractor if mentioned, or null",
    "target_project": "name of project if mentioned, or null",
    "field_to_edit": "specific field to edit (e.g., 'total_cost', 'capacity', 'project_name') or null",
    "new_value": "the new value to set, or null",
    "data_type": "cost" | "scope" | "equipment" | "general" | null,
    "response": "friendly message to user about what you understood",
    "needs_file": true/false,
    "needs_confirmation": true/false,
    "confidence": 0.0-1.0
}}

Common patterns:
- "Add cost data to Blattner" → action: add_cost_data, target_epc: Blattner
- "Upload Excel for Blattner" → action: add_cost_data, needs_file: true
- "Delete Mortenson proposal" → action: delete_proposal, target_epc: Mortenson
- "Change EPC Alpha's cost to $500M" → action: edit_proposal, target_epc: EPC Alpha, data_type: cost
- "Update Solar Project Charlie capacity to 450 MW" → action: edit_proposal, target_epc: null
- "Fix typo in project name" → action: edit_proposal
- "Show only proposals under $500M" → action: filter
- "What's the cheapest?" → action: question

Return ONLY the JSON, no other text.
"""

        try:
            response = self.client.chat.completions.create(
                model="gpt-4o-mini",
                messages=[
                    {"role": "system", "content": "You interpret user commands for a proposal management system. Always return valid JSON."},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.1,
                max_tokens=500
            )

            result_text = response.choices[0].message.content.strip()

            # Clean JSON if wrapped in markdown
            if result_text.startswith("```"):
                result_text = result_text.split("```")[1]
                if result_text.startswith("json"):
                    result_text = result_text[4:]

            result = json.loads(result_text)
            return result

        except Exception as e:
            return {
                'action': 'error',
                'response': f"Sorry, I couldn't understand that command. Error: {str(e)}",
                'needs_file': False,
                'needs_confirmation': False
            }

    def parse_excel_sov(self, excel_file) -> Optional[Dict]:
        """
        Parse Schedule of Values (SOV) Excel file to extract cost data.

        Returns cost data dict or None if parsing fails.
        """
        try:
            # Try reading different sheets
            xl = pd.ExcelFile(excel_file)

            # Look for common SOV sheet names
            possible_sheets = ['SOV', 'Schedule of Values', 'Costs', 'Pricing', 'Summary']
            sheet_name = None

            for sheet in xl.sheet_names:
                if any(name.lower() in sheet.lower() for name in possible_sheets):
                    sheet_name = sheet
                    break

            if not sheet_name:
                sheet_name = xl.sheet_names[0]  # Use first sheet

            df = pd.read_excel(excel_file, sheet_name=sheet_name)

            # Try to find total cost
            total_cost = None
            cost_breakdown = {}

            # Look for patterns in the data
            for col in df.columns:
                col_lower = str(col).lower()

                # Look for total cost
                if 'total' in col_lower and ('cost' in col_lower or 'price' in col_lower or 'amount' in col_lower):
                    # Get the last non-null value in this column
                    values = df[col].dropna()
                    if len(values) > 0:
                        try:
                            total_cost = float(values.iloc[-1])
                        except:
                            pass

            # Look for cost breakdown categories
            category_keywords = {
                'equipment': ['equipment', 'material', 'supplies'],
                'labor': ['labor', 'workforce', 'manpower'],
                'materials': ['materials', 'supplies'],
                'development': ['development', 'engineering', 'design'],
                'other': ['other', 'misc', 'miscellaneous']
            }

            # Try to extract breakdown from rows
            for idx, row in df.iterrows():
                row_text = ' '.join([str(val).lower() for val in row if pd.notna(val)])

                for category, keywords in category_keywords.items():
                    if any(keyword in row_text for keyword in keywords):
                        # Look for a number in this row
                        for val in row:
                            if pd.notna(val):
                                try:
                                    cost_breakdown[category] = float(val)
                                    break
                                except:
                                    pass

            # Calculate total if not found but we have breakdown
            if not total_cost and cost_breakdown:
                total_cost = sum(cost_breakdown.values())

            if total_cost:
                return {
                    'total_project_cost': total_cost,
                    'cost_breakdown': cost_breakdown if cost_breakdown else {
                        'equipment': None,
                        'labor': None,
                        'materials': None,
                        'development': None,
                        'other': None
                    },
                    'cost_per_watt_dc': None,  # Will calculate if we have capacity
                    'cost_per_watt_ac': None
                }

            return None

        except Exception as e:
            print(f"Error parsing Excel: {e}")
            return None

    def update_proposal_costs(self, proposals: List[Dict], epc_name: str, cost_data: Dict) -> Tuple[bool, str]:
        """
        Update a proposal with new cost data.

        Returns (success, message)
        """
        # Find the proposal
        target_proposal = None
        for proposal in proposals:
            current_epc = proposal.get('epc_contractor', {}).get('company_name', '')
            if epc_name.lower() in current_epc.lower():
                target_proposal = proposal
                break

        if not target_proposal:
            return False, f"Could not find proposal for {epc_name}"

        # Update costs
        if 'costs' not in target_proposal:
            target_proposal['costs'] = {}

        target_proposal['costs'].update(cost_data)

        # Calculate cost per watt if we have capacity
        if cost_data.get('total_project_cost'):
            capacity = target_proposal.get('capacity', {})
            if capacity.get('dc_mw'):
                dc_watts = capacity['dc_mw'] * 1_000_000
                target_proposal['costs']['cost_per_watt_dc'] = cost_data['total_project_cost'] / dc_watts
            if capacity.get('ac_mw'):
                ac_watts = capacity['ac_mw'] * 1_000_000
                target_proposal['costs']['cost_per_watt_ac'] = cost_data['total_project_cost'] / ac_watts

        return True, f"Successfully updated {epc_name} with cost data"

    def generate_response(self, action_result: Dict) -> str:
        """Generate a friendly response message based on action result."""
        if action_result.get('success'):
            return f"✅ {action_result.get('message', 'Action completed successfully')}"
        else:
            return f"❌ {action_result.get('message', 'Action failed')}"

    def edit_proposal_data(self, proposals: List[Dict], intent: Dict) -> Tuple[bool, str]:
        """
        Edit specific fields in a proposal based on user intent.

        Returns (success, message)
        """
        target_epc = intent.get('target_epc')
        target_project = intent.get('target_project')
        field_to_edit = intent.get('field_to_edit')
        new_value = intent.get('new_value')

        # Find matching proposals
        matching_proposals = []
        for proposal in proposals:
            epc_name = proposal.get('epc_contractor', {}).get('company_name', '')
            project_name = proposal.get('project_info', {}).get('project_name', '')

            # Match by EPC or project
            if target_epc and target_epc.lower() in epc_name.lower():
                matching_proposals.append(proposal)
            elif target_project and target_project.lower() in project_name.lower():
                matching_proposals.append(proposal)
            elif not target_epc and not target_project:
                # If no specific target, might be a general edit
                matching_proposals.append(proposal)

        if not matching_proposals:
            return False, f"Could not find proposal matching '{target_epc or target_project}'"

        # Use GPT to determine what to edit and how
        proposal_summary = []
        for p in matching_proposals:
            proposal_summary.append({
                'epc': p.get('epc_contractor', {}).get('company_name', 'Unknown'),
                'project': p.get('project_info', {}).get('project_name', 'Unknown'),
                'total_cost': p.get('costs', {}).get('total_project_cost'),
                'capacity_ac': p.get('capacity', {}).get('ac_mw'),
                'capacity_dc': p.get('capacity', {}).get('dc_mw'),
            })

        prompt = f"""User wants to edit proposal data.

User request: "{intent.get('response', '')}"
Matching proposals: {json.dumps(proposal_summary, indent=2)}
Field to edit: {field_to_edit}
New value: {new_value}

Return a JSON object specifying EXACTLY what to change:
{{
    "path": "the nested path to the field (e.g., 'costs.total_project_cost', 'capacity.ac_mw', 'project_info.project_name')",
    "value": the new value (with correct type - number, string, etc),
    "summary": "brief summary of the change"
}}

Return ONLY the JSON, no other text."""

        try:
            response = self.client.chat.completions.create(
                model="gpt-4o-mini",
                messages=[
                    {"role": "system", "content": "You determine the exact field path and value to edit in proposal data. Return valid JSON only."},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.1,
                max_tokens=300
            )

            result_text = response.choices[0].message.content.strip()

            # Clean JSON if wrapped in markdown
            if result_text.startswith("```"):
                result_text = result_text.split("```")[1]
                if result_text.startswith("json"):
                    result_text = result_text[4:]

            edit_spec = json.loads(result_text)

            # Apply the edit to all matching proposals
            path = edit_spec['path']
            value = edit_spec['value']

            for proposal in matching_proposals:
                # Navigate to the nested field
                parts = path.split('.')
                current = proposal
                for i, part in enumerate(parts[:-1]):
                    if part not in current:
                        current[part] = {}
                    current = current[part]

                # Set the value
                current[parts[-1]] = value

                # Recalculate cost per watt if total cost or capacity changed
                if 'costs' in path or 'capacity' in path:
                    total_cost = proposal.get('costs', {}).get('total_project_cost')
                    dc_mw = proposal.get('capacity', {}).get('dc_mw')
                    ac_mw = proposal.get('capacity', {}).get('ac_mw')

                    if total_cost and dc_mw:
                        proposal['costs']['cost_per_watt_dc'] = total_cost / (dc_mw * 1_000_000)
                    if total_cost and ac_mw:
                        proposal['costs']['cost_per_watt_ac'] = total_cost / (ac_mw * 1_000_000)

            count = len(matching_proposals)
            summary = edit_spec.get('summary', 'Updated proposal data')
            return True, f"{summary} ({count} proposal{'s' if count > 1 else ''} updated)"

        except Exception as e:
            return False, f"Error processing edit: {str(e)}"

    def delete_proposal(self, proposals: List[Dict], intent: Dict) -> Tuple[bool, str, List[int]]:
        """
        Delete proposal(s) based on user intent.

        Returns (success, message, indices_to_delete)
        """
        target_epc = intent.get('target_epc')
        target_project = intent.get('target_project')

        # Find matching proposals
        indices_to_delete = []
        deleted_names = []

        for idx, proposal in enumerate(proposals):
            epc_name = proposal.get('epc_contractor', {}).get('company_name', '')
            project_name = proposal.get('project_info', {}).get('project_name', '')

            # Match by EPC or project
            should_delete = False
            if target_epc and target_epc.lower() in epc_name.lower():
                should_delete = True
            elif target_project and target_project.lower() in project_name.lower():
                should_delete = True

            if should_delete:
                indices_to_delete.append(idx)
                deleted_names.append(f"{epc_name} - {project_name}")

        if not indices_to_delete:
            return False, f"Could not find proposal matching '{target_epc or target_project}'", []

        message = f"Will delete {len(indices_to_delete)} proposal(s):\n" + "\n".join(f"• {name}" for name in deleted_names)
        return True, message, indices_to_delete