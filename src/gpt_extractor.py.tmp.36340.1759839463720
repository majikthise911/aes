import openai
import json
from typing import Dict, Optional, List
import os
from dotenv import load_dotenv
from datetime import datetime

# Load environment variables from the config/.env file
env_path = os.path.join(os.path.dirname(os.path.dirname(__file__)), 'config', '.env')
load_dotenv(env_path)

class GPTExtractor:
    """Handles AI-powered data extraction from EPC proposal text."""

    def __init__(self):
        self.client = openai.OpenAI(api_key=os.getenv('OPENAI_API_KEY'))

    def chunk_text(self, text: str, max_chunk_size: int = 50000) -> List[str]:
        """Split text into chunks if it's too large."""
        if len(text) <= max_chunk_size:
            return [text]

        # Split by paragraphs first, then sentences if needed
        chunks = []
        current_chunk = ""

        paragraphs = text.split('\n\n')

        for paragraph in paragraphs:
            if len(current_chunk) + len(paragraph) <= max_chunk_size:
                current_chunk += paragraph + '\n\n'
            else:
                if current_chunk:
                    chunks.append(current_chunk.strip())
                current_chunk = paragraph + '\n\n'

        if current_chunk:
            chunks.append(current_chunk.strip())

        return chunks

    def extract_project_data(self, text: str) -> Dict:
        """Extract structured data from EPC proposal text using GPT."""

        # Check if we need to chunk the text
        chunks = self.chunk_text(text)

        if len(chunks) == 1:
            # Single chunk processing
            return self._extract_from_single_chunk(text)
        else:
            # Multi-chunk processing - extract from each chunk and merge
            return self._extract_from_multiple_chunks(chunks)

    def _extract_from_single_chunk(self, text: str) -> Dict:
        """Extract data from a single text chunk."""

        prompt = """
        You are an expert at extracting information from EPC (Engineering, Procurement, Construction) proposals for renewable energy projects.

        Extract the following information from the provided text and return it as a JSON object:

        {
            "project_info": {
                "project_name": "string",
                "location": {
                    "address": "string",
                    "city": "string",
                    "county": "string",
                    "state": "string",
                    "coordinates": {"lat": float, "lon": float} // if available
                },
                "jurisdiction": "string"
            },
            "epc_contractor": {
                "company_name": "string",
                "contact_person": "string",
                "phone": "string",
                "email": "string",
                "proposal_date": "string",
                "proposal_version": "string"
            },
            "technology": {
                "type": "string", // e.g., "PV", "BESS", "Wind", "PV+BESS", etc.
                "description": "string"
            },
            "capacity": {
                "ac_mw": float,
                "dc_mw": float,
                "storage_mwh": float // if applicable
            },
            "equipment": {
                "modules": {
                    "manufacturer": "string",
                    "model": "string",
                    "wattage": float
                },
                "inverters": {
                    "manufacturer": "string",
                    "model": "string"
                },
                "racking": {
                    "manufacturer": "string",
                    "type": "string"
                },
                "batteries": { // if applicable
                    "manufacturer": "string",
                    "model": "string",
                    "capacity_kwh": float
                }
            },
            "costs": {
                "total_project_cost": float,
                "cost_breakdown": {
                    "equipment": float,
                    "labor": float,
                    "materials": float,
                    "development": float,
                    "other": float
                },
                "cost_per_watt_dc": float,
                "cost_per_watt_ac": float
            },
            "scope": {
                "assumptions": ["list of key assumptions"],
                "exclusions": ["list of key exclusions/items not included"],
                "clarifications": ["list of clarifications and special conditions"],
                "inclusions": ["list of key items included in scope"]
            }
        }

        Important instructions:
        - If information is not available, use null for that field
        - For costs, look for dollar amounts and convert to numbers (remove $ and commas)
        - For locations, try to extract as much detail as possible
        - For scope section: carefully extract assumptions, exclusions, clarifications, and inclusions from the proposal
        - Look for sections titled "Assumptions", "Exclusions", "Clarifications", "Scope of Work", "Included", "Not Included", etc.
        - Extract the actual list items, not just section headers
        - Be conservative - only extract information you're confident about
        - Return ONLY valid JSON, no additional text, no markdown, no code blocks
        - Start your response with { and end with }
        - Do not include any explanatory text before or after the JSON

        Text to analyze:
        """

        try:
            response = self.client.chat.completions.create(
                model="gpt-4o",
                messages=[
                    {"role": "system", "content": "You are an expert at extracting structured data from technical documents."},
                    {"role": "user", "content": f"{prompt}\n\n{text}"}
                ],
                temperature=0.1,
                max_tokens=3000  # Reduced for faster response
            )

            raw_response = response.choices[0].message.content

            # Clean the response - remove markdown code blocks if present
            cleaned_response = self._clean_json_response(raw_response)

            extracted_data = json.loads(cleaned_response)
            return extracted_data

        except json.JSONDecodeError as e:
            # Log the actual response for debugging and try fallback
            raw_response = response.choices[0].message.content if 'response' in locals() else "No response"

            # Try a simpler fallback extraction
            fallback_result = self._create_fallback_result(raw_response if 'response' in locals() else "")
            if fallback_result:
                return fallback_result

            raise Exception(f"Error parsing GPT response as JSON: {str(e)}. Raw response: {raw_response[:500]}...")
        except Exception as e:
            raise Exception(f"Error extracting data with GPT: {str(e)}")

    def _extract_from_multiple_chunks(self, chunks: List[str]) -> Dict:
        """Extract data from multiple chunks and merge results."""
        results = []

        for i, chunk in enumerate(chunks):
            try:
                chunk_result = self._extract_from_single_chunk(chunk)
                if chunk_result:
                    results.append(chunk_result)
            except Exception as e:
                print(f"Warning: Failed to process chunk {i+1}: {str(e)}")
                continue

        if not results:
            raise Exception("Failed to extract data from any chunks")

        # Merge results - take the most complete data from all chunks
        merged_result = self._merge_extraction_results(results)
        return merged_result

    def _merge_extraction_results(self, results: List[Dict]) -> Dict:
        """Merge multiple extraction results into a single comprehensive result."""
        if not results:
            return {}

        if len(results) == 1:
            return results[0]

        # Start with the first result and merge others
        merged = results[0].copy()

        for result in results[1:]:
            # Merge project_info
            if result.get('project_info'):
                if not merged.get('project_info'):
                    merged['project_info'] = {}
                for key, value in result['project_info'].items():
                    if value and (not merged['project_info'].get(key) or merged['project_info'][key] in [None, 'N/A', '']):
                        merged['project_info'][key] = value

            # Merge other sections similarly
            for section in ['technology', 'capacity', 'equipment', 'costs']:
                if result.get(section):
                    if not merged.get(section):
                        merged[section] = {}
                    self._merge_section(merged[section], result[section])

        return merged

    def _merge_section(self, target: Dict, source: Dict) -> None:
        """Merge a section from source into target."""
        for key, value in source.items():
            if isinstance(value, dict) and isinstance(target.get(key), dict):
                self._merge_section(target[key], value)
            elif value and (not target.get(key) or target[key] in [None, 'N/A', '']):
                target[key] = value

    def _clean_json_response(self, response: str) -> str:
        """Clean GPT response to extract valid JSON."""
        if not response or not response.strip():
            raise Exception("Empty response from GPT")

        # Remove markdown code blocks
        if '```json' in response:
            start = response.find('```json') + 7
            end = response.find('```', start)
            if end != -1:
                response = response[start:end]
        elif '```' in response:
            start = response.find('```') + 3
            end = response.find('```', start)
            if end != -1:
                response = response[start:end]

        # Remove any leading/trailing text that isn't JSON
        response = response.strip()

        # Find the JSON object by looking for the first { and last }
        start_idx = response.find('{')
        end_idx = response.rfind('}')

        if start_idx == -1 or end_idx == -1 or start_idx >= end_idx:
            raise Exception(f"No valid JSON object found in response: {response[:200]}...")

        json_str = response[start_idx:end_idx + 1]

        # Basic validation - should start with { and end with }
        if not json_str.startswith('{') or not json_str.endswith('}'):
            raise Exception(f"Invalid JSON structure: {json_str[:200]}...")

        return json_str

    def _create_fallback_result(self, response: str) -> Optional[Dict]:
        """Create a basic result structure when JSON parsing fails."""
        try:
            # Create a minimal valid structure
            fallback = {
                "project_info": {
                    "project_name": "Data extraction failed - manual review required",
                    "location": {
                        "address": None,
                        "city": None,
                        "county": None,
                        "state": None,
                        "coordinates": None
                    },
                    "jurisdiction": None
                },
                "epc_contractor": {
                    "company_name": "Unknown EPC",
                    "contact_person": None,
                    "phone": None,
                    "email": None,
                    "proposal_date": None,
                    "proposal_version": None
                },
                "technology": {
                    "type": "Unknown",
                    "description": None
                },
                "capacity": {
                    "ac_mw": None,
                    "dc_mw": None,
                    "storage_mwh": None
                },
                "equipment": {
                    "modules": {"manufacturer": None, "model": None, "wattage": None},
                    "inverters": {"manufacturer": None, "model": None},
                    "racking": {"manufacturer": None, "type": None},
                    "batteries": {"manufacturer": None, "model": None, "capacity_kwh": None}
                },
                "costs": {
                    "total_project_cost": None,
                    "cost_breakdown": {"equipment": None, "labor": None, "materials": None, "development": None, "other": None},
                    "cost_per_watt_dc": None,
                    "cost_per_watt_ac": None
                }
            }

            # Add a note about the parsing failure
            fallback["parsing_note"] = f"JSON parsing failed. Response preview: {response[:200]}..."

            return fallback

        except Exception:
            return None

    def extract_scope_details(self, text: str) -> Dict:
        """Extract detailed scope information (assumptions, exclusions, clarifications) from proposal text.

        Uses gpt-4o-mini for faster, cheaper extraction of structured scope data.
        """

        prompt = """Extract ALL scope items from these sections:

1. ASSUMPTIONS - What's assumed (look for: "Assumptions", "Basis of Estimate", "Our Proposal Assumes")
2. EXCLUSIONS - What's NOT included (look for: "Exclusions", "Not Included", "Out of Scope", "Exceptions")
3. CLARIFICATIONS - Special conditions (look for: "Clarifications", "Notes", "Special Conditions")
4. INCLUSIONS - What's included (look for: "Inclusions", "Scope of Work", "Included Items")

Extract complete items, not fragments. Return JSON:
{
  "assumptions": ["item1", "item2", ...],
  "exclusions": ["item1", "item2", ...],
  "clarifications": ["item1", "item2", ...],
  "inclusions": ["item1", "item2", ...]
}

Return empty arrays [] if sections not found. No explanatory text, only JSON.
"""

        try:
            response = self.client.chat.completions.create(
                model="gpt-4o-mini",  # Faster and cheaper for structured extraction
                messages=[
                    {"role": "system", "content": "Extract structured scope data from construction proposals. Be thorough and precise."},
                    {"role": "user", "content": f"{prompt}\n\n{text}"}
                ],
                temperature=0.1,
                max_tokens=3000
            )

            raw_response = response.choices[0].message.content
            cleaned_response = self._clean_json_response(raw_response)
            scope_data = json.loads(cleaned_response)

            return scope_data

        except Exception as e:
            # Return empty structure if extraction fails
            return {
                "assumptions": [],
                "exclusions": [],
                "clarifications": [],
                "inclusions": []
            }

    def extract_location_coordinates(self, address: str) -> Optional[Dict[str, float]]:
        """Extract coordinates from an address using GPT."""

        prompt = f"""
        Convert the following address to latitude and longitude coordinates.
        Return only a JSON object with "lat" and "lon" fields as floats.
        If you cannot determine coordinates, return null.

        Address: {address}
        """

        try:
            response = self.client.chat.completions.create(
                model="gpt-3.5-turbo",
                messages=[
                    {"role": "user", "content": prompt}
                ],
                temperature=0.1,
                max_tokens=100
            )

            result = json.loads(response.choices[0].message.content)
            if result and "lat" in result and "lon" in result:
                return {"lat": float(result["lat"]), "lon": float(result["lon"])}
            return None

        except:
            return None

    def generate_epc_recommendation_report(self, proposals_data: List[Dict]) -> str:
        """Generate a comprehensive EPC recommendation report using GPT."""

        if not proposals_data:
            return "No proposals available for analysis."

        # Prepare the data summary for GPT analysis
        summary = self._prepare_proposals_summary(proposals_data)

        prompt = f"""
        You are an expert EPC (Engineering, Procurement, Construction) consultant specializing in renewable energy project evaluation. You have been asked to analyze multiple EPC contractor proposals for the same project and provide a comprehensive recommendation.

        Based on the proposal data provided, please generate a detailed recommendation report that includes:

        1. **EXECUTIVE SUMMARY**
           - Your top recommended EPC contractor
           - Key reasoning in 2-3 sentences

        2. **DETAILED ANALYSIS**
           - Cost Analysis: Compare total costs, cost per watt, and cost breakdowns
           - Technical Analysis: Evaluate equipment choices, technology approaches
           - Risk Assessment: Identify potential risks with each contractor
           - Value Analysis: Consider value proposition beyond just lowest cost

        3. **CONTRACTOR PROFILES**
           - Brief assessment of each EPC contractor's proposal
           - Strengths and weaknesses of each

        4. **FINANCIAL COMPARISON**
           - Cost ranking and analysis
           - Value for money assessment
           - Financial risk considerations

        5. **TECHNICAL EVALUATION**
           - Equipment quality and reliability
           - Technology compatibility
           - Installation approach

        6. **RECOMMENDATION & JUSTIFICATION**
           - Final recommendation with detailed justification
           - Risk mitigation suggestions
           - Next steps and considerations

        7. **ALTERNATIVE SCENARIOS**
           - If budget is the primary concern
           - If quality/reliability is the primary concern
           - If timeline is critical

        Please be objective, thorough, and provide actionable insights. Focus on practical business considerations that would help in making the final EPC selection decision.

        PROPOSAL DATA:
        {summary}

        Please provide a well-structured, professional report suitable for executive decision-making.
        """

        try:
            response = self.client.chat.completions.create(
                model="gpt-4o",
                messages=[
                    {"role": "system", "content": "You are an expert EPC consultant and technical advisor with 20+ years of experience in renewable energy project evaluation and contractor selection."},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.3,
                max_tokens=6000
            )

            return response.choices[0].message.content

        except Exception as e:
            return f"Error generating recommendation report: {str(e)}"

    def _prepare_proposals_summary(self, proposals_data: List[Dict]) -> str:
        """Prepare a structured summary of proposals for GPT analysis."""
        summary = []

        for i, proposal in enumerate(proposals_data, 1):
            # Safely extract nested dictionaries, defaulting to empty dict if None
            epc = proposal.get('epc_contractor') or {}
            costs = proposal.get('costs') or {}
            equipment = proposal.get('equipment') or {}
            capacity = proposal.get('capacity') or {}
            project_info = proposal.get('project_info') or {}
            technology = proposal.get('technology') or {}

            # Safely extract equipment sub-sections
            modules = equipment.get('modules') or {}
            inverters = equipment.get('inverters') or {}
            racking = equipment.get('racking') or {}
            batteries = equipment.get('batteries') or {}
            cost_breakdown = costs.get('cost_breakdown') or {}

            # Helper function to format costs
            def format_cost(value):
                if value is None or value == 'N/A':
                    return 'N/A'
                try:
                    return f"${float(value):,.2f}"
                except (ValueError, TypeError):
                    return 'N/A'

            # Helper function to safely get string values
            def safe_get(d, key, default='N/A'):
                val = d.get(key, default)
                return val if val is not None else default

            proposal_summary = f"""
PROPOSAL #{i} - {safe_get(epc, 'company_name', 'Unknown EPC')}
=================================================
EPC Contractor: {safe_get(epc, 'company_name', 'Unknown')}
Contact: {safe_get(epc, 'contact_person')}
Proposal Date: {safe_get(epc, 'proposal_date')}

Project Details:
- Project Name: {safe_get(project_info, 'project_name')}
- Technology: {safe_get(technology, 'type')}
- AC Capacity: {safe_get(capacity, 'ac_mw')} MW
- DC Capacity: {safe_get(capacity, 'dc_mw')} MW

Financial Details:
- Total Project Cost: {format_cost(costs.get('total_project_cost'))}
- Cost per Watt DC: {format_cost(costs.get('cost_per_watt_dc'))}
- Equipment Cost: {format_cost(cost_breakdown.get('equipment'))}
- Labor Cost: {format_cost(cost_breakdown.get('labor'))}
- Materials Cost: {format_cost(cost_breakdown.get('materials'))}

Equipment Specifications:
- Solar Modules: {safe_get(modules, 'manufacturer')} {safe_get(modules, 'model', '')} ({safe_get(modules, 'wattage')}W)
- Inverters: {safe_get(inverters, 'manufacturer')} {safe_get(inverters, 'model', '')}
- Racking: {safe_get(racking, 'manufacturer')} ({safe_get(racking, 'type')})
- Batteries: {safe_get(batteries, 'manufacturer')} {safe_get(batteries, 'model', '')} (if applicable)

Scope of Work:
- Assumptions: {len(proposal.get('scope', {}).get('assumptions', []))} items
- Exclusions: {len(proposal.get('scope', {}).get('exclusions', []))} items
- Inclusions: {len(proposal.get('scope', {}).get('inclusions', []))} items
- Clarifications: {len(proposal.get('scope', {}).get('clarifications', []))} items
"""
            summary.append(proposal_summary)

        return '\n'.join(summary)

    def analyze_scope_comprehensiveness(self, proposals_data: List[Dict]) -> Dict:
        """
        Multi-chain reasoning analysis of scope comprehensiveness across proposals.

        Uses a 3-chain approach:
        1. Initial qualitative analysis of each proposal's scope
        2. Significance evaluation of inclusions/exclusions
        3. Self-critique and validation

        Returns comprehensive analysis with scores and reasoning.
        """
        if not proposals_data or len(proposals_data) < 2:
            return {
                "error": "Need at least 2 proposals for comparison",
                "analysis": None
            }

        # Prepare scope data for analysis
        scope_summary = self._prepare_scope_summary(proposals_data)

        # Chain 1: Initial qualitative analysis
        chain1_analysis = self._chain1_initial_scope_analysis(scope_summary)

        # Chain 2: Significance evaluation
        chain2_evaluation = self._chain2_significance_evaluation(scope_summary, chain1_analysis)

        # Chain 3: Self-critique and validation
        chain3_validation = self._chain3_self_critique(scope_summary, chain1_analysis, chain2_evaluation)

        return {
            "initial_analysis": chain1_analysis,
            "significance_evaluation": chain2_evaluation,
            "final_assessment": chain3_validation,
            "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        }

    def _prepare_scope_summary(self, proposals_data: List[Dict]) -> str:
        """Prepare scope data for multi-chain analysis."""
        summary = []

        for i, proposal in enumerate(proposals_data, 1):
            epc = proposal.get('epc_contractor') or {}
            scope = proposal.get('scope') or {}

            epc_name = epc.get('company_name', f'EPC #{i}')

            inclusions = scope.get('inclusions', [])
            exclusions = scope.get('exclusions', [])
            assumptions = scope.get('assumptions', [])
            clarifications = scope.get('clarifications', [])

            proposal_scope = f"""
PROPOSAL #{i} - {epc_name}
{'=' * 60}

INCLUSIONS ({len(inclusions)} items):
{self._format_list_items(inclusions)}

EXCLUSIONS ({len(exclusions)} items):
{self._format_list_items(exclusions)}

ASSUMPTIONS ({len(assumptions)} items):
{self._format_list_items(assumptions)}

CLARIFICATIONS ({len(clarifications)} items):
{self._format_list_items(clarifications)}
"""
            summary.append(proposal_scope)

        return '\n'.join(summary)

    def _format_list_items(self, items: List[str]) -> str:
        """Format list items for display."""
        if not items:
            return "  (None listed)"
        return '\n'.join([f"  • {item}" for item in items])

    def _chain1_initial_scope_analysis(self, scope_summary: str) -> str:
        """Chain 1: Initial qualitative analysis of scope items."""

        prompt = f"""You are an expert construction contract analyst specializing in EPC proposals for renewable energy projects.

Analyze the scope data from multiple EPC proposals below. For each proposal, provide a QUALITATIVE assessment of:

1. **Inclusions Quality**: Are the inclusions comprehensive and detailed? Do they cover typical EPC scope items (design, engineering, procurement, construction, commissioning, testing, warranty, etc.)?

2. **Exclusions Significance**: Are the exclusions minor/typical items, or are they excluding critical items that should normally be included in an EPC contract?

3. **Assumptions Reasonableness**: Are the assumptions reasonable and standard for the industry, or are there red flags?

4. **Overall Scope Coverage**: Based on the items listed, which proposal appears to have the most complete and comprehensive scope?

Do NOT simply count items. Focus on:
- What types of items are included vs excluded
- Whether exclusions are shifting risk/cost to the owner
- Whether critical EPC responsibilities are covered
- Industry best practices for solar EPC contracts

SCOPE DATA:
{scope_summary}

Provide your analysis in a structured format with clear assessments for each proposal."""

        try:
            response = self.client.chat.completions.create(
                model="gpt-4o",
                messages=[
                    {"role": "system", "content": "You are an expert EPC contract analyst with 15+ years of experience in renewable energy construction contracts."},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.3,
                max_tokens=3000
            )

            return response.choices[0].message.content

        except Exception as e:
            return f"Error in Chain 1 analysis: {str(e)}"

    def _chain2_significance_evaluation(self, scope_summary: str, chain1_analysis: str) -> str:
        """Chain 2: Evaluate significance of inclusions and exclusions."""

        prompt = f"""You are an expert construction contract analyst. You previously provided an initial analysis of EPC proposal scopes.

Now, dig deeper into the SIGNIFICANCE of inclusions and exclusions:

**Your previous analysis:**
{chain1_analysis}

**Original scope data:**
{scope_summary}

For each proposal, evaluate:

1. **Critical Exclusions**: Identify any exclusions that would require the owner to procure separately or incur additional costs. Rate severity (High/Medium/Low impact to owner).

2. **Value of Inclusions**: Beyond just listing items, assess whether the inclusions demonstrate a turnkey approach vs. a limited scope requiring owner involvement.

3. **Risk Transfer**: Analyze how assumptions and exclusions shift risk. Which proposal keeps more risk with the EPC (better for owner)?

4. **Cost Implications**: Identify exclusions that will definitely require additional owner spending. Estimate relative cost impact.

5. **Completeness Score**: For each proposal, rate the scope completeness on a scale of 1-10, where:
   - 10 = Fully turnkey, comprehensive EPC scope with minimal exclusions
   - 5 = Moderate scope with some notable exclusions
   - 1 = Limited scope with many critical exclusions

Provide specific examples and clear reasoning."""

        try:
            response = self.client.chat.completions.create(
                model="gpt-4o",
                messages=[
                    {"role": "system", "content": "You are an expert at evaluating construction contract risk and scope comprehensiveness."},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.3,
                max_tokens=3000
            )

            return response.choices[0].message.content

        except Exception as e:
            return f"Error in Chain 2 evaluation: {str(e)}"

    def _chain3_self_critique(self, scope_summary: str, chain1_analysis: str, chain2_evaluation: str) -> str:
        """Chain 3: Self-critique and validation of previous analysis."""

        prompt = f"""You are a senior technical reviewer validating an analysis of EPC proposal scopes.

Review the analysis below and perform a critical self-check:

**Chain 1 - Initial Analysis:**
{chain1_analysis}

**Chain 2 - Significance Evaluation:**
{chain2_evaluation}

**Original Data:**
{scope_summary}

Your task:
1. **Validate Logic**: Does the analysis make logical sense? Are there any contradictions or unsupported claims?

2. **Challenge Assumptions**: Question whether the conclusions are justified by the data. Are there alternative interpretations?

3. **Identify Gaps**: What important considerations might have been missed?

4. **Re-evaluate if Needed**: If you find flaws in the previous analysis, provide a corrected assessment.

5. **Final Ranking**: Provide a final ranking of proposals from most to least comprehensive scope, with clear justification.

6. **Recommendation**: Which proposal offers the best scope coverage? Consider both comprehensiveness and risk allocation.

Be critical and objective. If the previous analysis needs correction, say so clearly."""

        try:
            response = self.client.chat.completions.create(
                model="gpt-4o",
                messages=[
                    {"role": "system", "content": "You are a critical reviewer ensuring analytical rigor and accuracy. Challenge weak reasoning and validate conclusions."},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.3,
                max_tokens=3000
            )

            return response.choices[0].message.content

        except Exception as e:
            return f"Error in Chain 3 validation: {str(e)}"

    def query_proposals_with_ai(self, user_query: str, proposals_data: List[Dict]) -> List[Dict]:
        """
        Use AI to interpret natural language query and filter proposals.

        Args:
            user_query: Natural language query from user
            proposals_data: List of all proposals

        Returns:
            Filtered list of proposals matching the query
        """

        # Prepare proposal summary for AI
        proposal_summary = self._prepare_query_summary(proposals_data)

        prompt = f"""You are a database query assistant. A user wants to query their EPC proposal database.

User's question: "{user_query}"

Available proposals:
{proposal_summary}

Your task:
1. Interpret the user's natural language query
2. Identify which proposals match the criteria
3. Return a JSON array of proposal indices (0-based) that match

Response format:
{{
  "matching_indices": [0, 2, 5],
  "explanation": "Brief explanation of what matched"
}}

Important:
- Only return valid indices (0 to {len(proposals_data)-1})
- If no proposals match, return empty array
- Consider cost ranges, EPC names, technology types, scope items, etc.
- Be flexible with interpretation (e.g., "under $500M" means total_cost < 500000000)

Return ONLY the JSON object, no other text."""

        try:
            response = self.client.chat.completions.create(
                model="gpt-4o-mini",  # Faster for query interpretation
                messages=[
                    {"role": "system", "content": "You are a database query interpreter that converts natural language to proposal filters."},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.1,
                max_tokens=1000
            )

            raw_response = response.choices[0].message.content
            cleaned_response = self._clean_json_response(raw_response)
            result = json.loads(cleaned_response)

            # Extract matching proposals
            matching_indices = result.get('matching_indices', [])
            filtered_proposals = [proposals_data[i] for i in matching_indices if 0 <= i < len(proposals_data)]

            return filtered_proposals

        except Exception as e:
            # Fallback: return empty list on error
            print(f"AI query error: {str(e)}")
            return []

    def _prepare_query_summary(self, proposals_data: List[Dict]) -> str:
        """Prepare a concise summary of proposals for query processing."""
        summary = []

        for i, proposal in enumerate(proposals_data):
            epc = proposal.get('epc_contractor', {})
            costs = proposal.get('costs', {})
            tech = proposal.get('technology', {})
            scope = proposal.get('scope', {})
            capacity = proposal.get('capacity', {})

            summary.append(f"""[{i}] {epc.get('company_name', 'Unknown')} - ${costs.get('total_project_cost', 0):,.0f} - {tech.get('type', 'N/A')} - {capacity.get('ac_mw', 0)}MW AC - {len(scope.get('inclusions', []))} incl / {len(scope.get('exclusions', []))} excl""")

        return '\n'.join(summary)

    def generate_executive_summary(self, full_report: str) -> str:
        """
        Generate an executive summary from a detailed report.

        Args:
            full_report: The full detailed report text

        Returns:
            Executive summary (1-2 pages max)
        """

        prompt = f"""You are an executive report writer. Create a concise executive summary from this detailed analysis.

DETAILED REPORT:
{full_report}

Create an executive summary that includes:

1. **TOP RECOMMENDATION** (2-3 sentences)
   - Which EPC to select and why

2. **KEY FINDINGS** (3-5 bullet points)
   - Most important insights from the analysis

3. **COST COMPARISON** (2-3 sentences)
   - Range of bids and key cost differences

4. **CRITICAL CONSIDERATIONS** (2-3 bullet points)
   - Important factors for decision-making

5. **NEXT STEPS** (2-3 bullet points)
   - Immediate actions to take

Keep it to 1 page maximum. Focus on actionable insights for executives.
No lengthy explanations - just the critical information needed for decision-making.
"""

        try:
            response = self.client.chat.completions.create(
                model="gpt-4o-mini",  # Faster for summarization
                messages=[
                    {"role": "system", "content": "You are an expert at creating concise executive summaries from detailed reports."},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.3,
                max_tokens=1000
            )

            return response.choices[0].message.content

        except Exception as e:
            return f"Error generating executive summary: {str(e)}"