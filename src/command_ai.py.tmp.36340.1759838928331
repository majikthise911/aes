import openai
import os
import json
from typing import Dict, List, Optional, Tuple
import pandas as pd

class CommandAI:
    """AI assistant that interprets natural language commands to control the app."""

    def __init__(self):
        self.client = openai.OpenAI(api_key=os.getenv('OPENAI_API_KEY'))
        self.pending_file = None
        self.pending_action = None

    def interpret_command(self, user_message: str, proposals: List[Dict], has_file: bool = False) -> Dict:
        """
        Interpret user command and determine action to take.

        Returns:
            {
                'action': 'update_proposal' | 'delete_proposal' | 'filter' | 'question' | 'upload_file' | 'clarify',
                'target': 'epc_name or proposal identifier',
                'parameters': {...},
                'response': 'message to user',
                'needs_file': bool,
                'needs_confirmation': bool
            }
        """

        # Get list of EPC names for context
        epc_names = [p.get('epc_contractor', {}).get('company_name', 'Unknown') for p in proposals]

        prompt = f"""You are an AI assistant that interprets user commands for an EPC proposal management system.

Current proposals in system: {', '.join(epc_names) if epc_names else 'None'}

User said: "{user_message}"
File uploaded with message: {has_file}

Determine the user's intent and return a JSON object with:
{{
    "action": "update_proposal" | "delete_proposal" | "add_cost_data" | "filter" | "question" | "upload_file" | "clarify",
    "target_epc": "name of EPC contractor if mentioned, or null",
    "data_type": "cost" | "scope" | "equipment" | "general" | null,
    "response": "friendly message to user about what you understood",
    "needs_file": true/false,
    "needs_confirmation": true/false,
    "confidence": 0.0-1.0
}}

Common patterns:
- "Add cost data to Blattner" → action: add_cost_data, target_epc: Blattner
- "Upload Excel for Blattner" → action: add_cost_data, needs_file: true
- "Delete Mortenson proposal" → action: delete_proposal, target_epc: Mortenson
- "Change EPC Alpha's cost to $500M" → action: edit_proposal, target_epc: EPC Alpha, data_type: cost
- "Update Solar Project Charlie capacity to 450 MW" → action: edit_proposal, target_epc: null
- "Fix typo in project name" → action: edit_proposal
- "Show only proposals under $500M" → action: filter
- "What's the cheapest?" → action: question

Return ONLY the JSON, no other text.
"""

        try:
            response = self.client.chat.completions.create(
                model="gpt-4o-mini",
                messages=[
                    {"role": "system", "content": "You interpret user commands for a proposal management system. Always return valid JSON."},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.1,
                max_tokens=500
            )

            result_text = response.choices[0].message.content.strip()

            # Clean JSON if wrapped in markdown
            if result_text.startswith("```"):
                result_text = result_text.split("```")[1]
                if result_text.startswith("json"):
                    result_text = result_text[4:]

            result = json.loads(result_text)
            return result

        except Exception as e:
            return {
                'action': 'error',
                'response': f"Sorry, I couldn't understand that command. Error: {str(e)}",
                'needs_file': False,
                'needs_confirmation': False
            }

    def parse_excel_sov(self, excel_file) -> Optional[Dict]:
        """
        Parse Schedule of Values (SOV) Excel file to extract cost data.

        Returns cost data dict or None if parsing fails.
        """
        try:
            # Try reading different sheets
            xl = pd.ExcelFile(excel_file)

            # Look for common SOV sheet names
            possible_sheets = ['SOV', 'Schedule of Values', 'Costs', 'Pricing', 'Summary']
            sheet_name = None

            for sheet in xl.sheet_names:
                if any(name.lower() in sheet.lower() for name in possible_sheets):
                    sheet_name = sheet
                    break

            if not sheet_name:
                sheet_name = xl.sheet_names[0]  # Use first sheet

            df = pd.read_excel(excel_file, sheet_name=sheet_name)

            # Try to find total cost
            total_cost = None
            cost_breakdown = {}

            # Look for patterns in the data
            for col in df.columns:
                col_lower = str(col).lower()

                # Look for total cost
                if 'total' in col_lower and ('cost' in col_lower or 'price' in col_lower or 'amount' in col_lower):
                    # Get the last non-null value in this column
                    values = df[col].dropna()
                    if len(values) > 0:
                        try:
                            total_cost = float(values.iloc[-1])
                        except:
                            pass

            # Look for cost breakdown categories
            category_keywords = {
                'equipment': ['equipment', 'material', 'supplies'],
                'labor': ['labor', 'workforce', 'manpower'],
                'materials': ['materials', 'supplies'],
                'development': ['development', 'engineering', 'design'],
                'other': ['other', 'misc', 'miscellaneous']
            }

            # Try to extract breakdown from rows
            for idx, row in df.iterrows():
                row_text = ' '.join([str(val).lower() for val in row if pd.notna(val)])

                for category, keywords in category_keywords.items():
                    if any(keyword in row_text for keyword in keywords):
                        # Look for a number in this row
                        for val in row:
                            if pd.notna(val):
                                try:
                                    cost_breakdown[category] = float(val)
                                    break
                                except:
                                    pass

            # Calculate total if not found but we have breakdown
            if not total_cost and cost_breakdown:
                total_cost = sum(cost_breakdown.values())

            if total_cost:
                return {
                    'total_project_cost': total_cost,
                    'cost_breakdown': cost_breakdown if cost_breakdown else {
                        'equipment': None,
                        'labor': None,
                        'materials': None,
                        'development': None,
                        'other': None
                    },
                    'cost_per_watt_dc': None,  # Will calculate if we have capacity
                    'cost_per_watt_ac': None
                }

            return None

        except Exception as e:
            print(f"Error parsing Excel: {e}")
            return None

    def update_proposal_costs(self, proposals: List[Dict], epc_name: str, cost_data: Dict) -> Tuple[bool, str]:
        """
        Update a proposal with new cost data.

        Returns (success, message)
        """
        # Find the proposal
        target_proposal = None
        for proposal in proposals:
            current_epc = proposal.get('epc_contractor', {}).get('company_name', '')
            if epc_name.lower() in current_epc.lower():
                target_proposal = proposal
                break

        if not target_proposal:
            return False, f"Could not find proposal for {epc_name}"

        # Update costs
        if 'costs' not in target_proposal:
            target_proposal['costs'] = {}

        target_proposal['costs'].update(cost_data)

        # Calculate cost per watt if we have capacity
        if cost_data.get('total_project_cost'):
            capacity = target_proposal.get('capacity', {})
            if capacity.get('dc_mw'):
                dc_watts = capacity['dc_mw'] * 1_000_000
                target_proposal['costs']['cost_per_watt_dc'] = cost_data['total_project_cost'] / dc_watts
            if capacity.get('ac_mw'):
                ac_watts = capacity['ac_mw'] * 1_000_000
                target_proposal['costs']['cost_per_watt_ac'] = cost_data['total_project_cost'] / ac_watts

        return True, f"Successfully updated {epc_name} with cost data"

    def generate_response(self, action_result: Dict) -> str:
        """Generate a friendly response message based on action result."""
        if action_result.get('success'):
            return f"✅ {action_result.get('message', 'Action completed successfully')}"
        else:
            return f"❌ {action_result.get('message', 'Action failed')}"